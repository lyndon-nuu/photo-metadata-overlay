import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';\nimport { imageProcessingService } from '../../services/image-processing.service';\nimport {\n  mockPhotoMetadata,\n  mockOverlaySettings,\n  mockFrameSettings,\n  createMockFile,\n  createMockImage,\n  createMockCanvas,\n  PerformanceMonitor,\n  getMemoryUsage,\n  createLargeTestFile,\n  waitFor,\n  restoreMocks,\n} from '../../test/test-utils';\n\n// Mock DOM APIs\nObject.defineProperty(global, 'HTMLCanvasElement', {\n  value: class MockHTMLCanvasElement {\n    width = 0;\n    height = 0;\n    getContext = vi.fn(() => ({\n      clearRect: vi.fn(),\n      drawImage: vi.fn(),\n      fillRect: vi.fn(),\n      fillText: vi.fn(),\n      measureText: vi.fn(() => ({ width: 100 })),\n      beginPath: vi.fn(),\n      moveTo: vi.fn(),\n      lineTo: vi.fn(),\n      quadraticCurveTo: vi.fn(),\n      closePath: vi.fn(),\n      fill: vi.fn(),\n      stroke: vi.fn(),\n      save: vi.fn(),\n      restore: vi.fn(),\n      createLinearGradient: vi.fn(() => ({\n        addColorStop: vi.fn(),\n      })),\n      imageSmoothingEnabled: true,\n      imageSmoothingQuality: 'high',\n      globalAlpha: 1,\n      fillStyle: '#000000',\n      strokeStyle: '#000000',\n      lineWidth: 1,\n      font: '16px Arial',\n      textBaseline: 'top',\n      shadowColor: 'transparent',\n      shadowBlur: 0,\n      shadowOffsetX: 0,\n      shadowOffsetY: 0,\n    }));\n    toBlob = vi.fn((callback) => {\n      const blob = new Blob(['mock-image-data'], { type: 'image/jpeg' });\n      callback?.(blob);\n    });\n  },\n});\n\nObject.defineProperty(global, 'Image', {\n  value: class MockImage {\n    onload: (() => void) | null = null;\n    onerror: (() => void) | null = null;\n    src = '';\n    naturalWidth = 1920;\n    naturalHeight = 1080;\n    crossOrigin = '';\n    \n    constructor() {\n      setTimeout(() => {\n        if (this.onload) {\n          this.onload();\n        }\n      }, 10);\n    }\n  },\n});\n\nObject.defineProperty(global, 'URL', {\n  value: {\n    createObjectURL: vi.fn(() => 'blob:mock-url'),\n    revokeObjectURL: vi.fn(),\n  },\n});\n\ndescribe('Image Processing E2E Tests', () => {\n  let performanceMonitor: PerformanceMonitor;\n\n  beforeEach(() => {\n    performanceMonitor = new PerformanceMonitor();\n    vi.clearAllMocks();\n  });\n\n  afterEach(() => {\n    restoreMocks();\n  });\n\n  describe('Image Loading Performance', () => {\n    it('should load small images quickly', async () => {\n      const file = createMockFile('small-image.jpg', 'image/jpeg', 100000); // 100KB\n      \n      performanceMonitor.start();\n      const image = await imageProcessingService.loadImage(file);\n      const duration = performanceMonitor.end('small-image-load');\n      \n      expect(image).toBeDefined();\n      expect(duration).toBeLessThan(1000); // Should load in less than 1 second\n    });\n\n    it('should handle large images with performance optimization', async () => {\n      const file = createLargeTestFile(6000, 4000, 'large-image.jpg');\n      \n      performanceMonitor.start();\n      const image = await imageProcessingService.loadImage(file);\n      const duration = performanceMonitor.end('large-image-load');\n      \n      expect(image).toBeDefined();\n      expect(duration).toBeLessThan(5000); // Should load in less than 5 seconds\n    });\n\n    it('should cache loaded images for better performance', async () => {\n      const file = createMockFile('cached-image.jpg', 'image/jpeg', 500000);\n      \n      // First load\n      performanceMonitor.start();\n      const image1 = await imageProcessingService.loadImage(file);\n      const firstLoadTime = performanceMonitor.end('first-load');\n      \n      // Second load (should be from cache)\n      performanceMonitor.start();\n      const image2 = await imageProcessingService.loadImage(file);\n      const secondLoadTime = performanceMonitor.end('second-load');\n      \n      expect(image1).toBeDefined();\n      expect(image2).toBeDefined();\n      expect(secondLoadTime).toBeLessThan(firstLoadTime * 0.1); // Cache should be much faster\n    });\n\n    it('should reject files that are too large', async () => {\n      const file = createMockFile('huge-image.jpg', 'image/jpeg', 60 * 1024 * 1024); // 60MB\n      \n      await expect(imageProcessingService.loadImage(file))\n        .rejects\n        .toThrow('文件过大');\n    });\n\n    it('should reject unsupported file types', async () => {\n      const file = createMockFile('document.pdf', 'application/pdf', 1000000);\n      \n      await expect(imageProcessingService.loadImage(file))\n        .rejects\n        .toThrow('不支持的文件类型');\n    });\n  });\n\n  describe('Overlay Processing Performance', () => {\n    it('should apply overlay efficiently', async () => {\n      const file = createMockFile('test-image.jpg', 'image/jpeg', 1000000);\n      const image = await imageProcessingService.loadImage(file);\n      \n      performanceMonitor.start();\n      const canvas = await imageProcessingService.applyOverlay(\n        image,\n        mockPhotoMetadata,\n        mockOverlaySettings\n      );\n      const duration = performanceMonitor.end('overlay-processing');\n      \n      expect(canvas).toBeDefined();\n      expect(canvas.width).toBeGreaterThan(0);\n      expect(canvas.height).toBeGreaterThan(0);\n      expect(duration).toBeLessThan(2000); // Should process in less than 2 seconds\n    });\n\n    it('should handle overlay with brand logo', async () => {\n      const file = createMockFile('test-image.jpg', 'image/jpeg', 1000000);\n      const image = await imageProcessingService.loadImage(file);\n      \n      const overlayWithLogo = {\n        ...mockOverlaySettings,\n        displayItems: {\n          ...mockOverlaySettings.displayItems,\n          brandLogo: true,\n        },\n      };\n      \n      performanceMonitor.start();\n      const canvas = await imageProcessingService.applyOverlay(\n        image,\n        mockPhotoMetadata,\n        overlayWithLogo\n      );\n      const duration = performanceMonitor.end('overlay-with-logo');\n      \n      expect(canvas).toBeDefined();\n      expect(duration).toBeLessThan(3000); // Should process in less than 3 seconds\n    });\n\n    it('should skip overlay when no data is available', async () => {\n      const file = createMockFile('test-image.jpg', 'image/jpeg', 1000000);\n      const image = await imageProcessingService.loadImage(file);\n      \n      const emptyMetadata = {\n        ...mockPhotoMetadata,\n        camera: { make: '', model: '' },\n        settings: { aperture: '', shutterSpeed: '', iso: 0, focalLength: '', flash: '' },\n      };\n      \n      const overlaySettings = {\n        ...mockOverlaySettings,\n        displayItems: {\n          camera: false,\n          settings: false,\n          timestamp: false,\n          location: false,\n          brandLogo: false,\n          customText: false,\n        },\n      };\n      \n      performanceMonitor.start();\n      const canvas = await imageProcessingService.applyOverlay(\n        image,\n        emptyMetadata,\n        overlaySettings\n      );\n      const duration = performanceMonitor.end('no-overlay');\n      \n      expect(canvas).toBeDefined();\n      expect(duration).toBeLessThan(100); // Should be very fast when no overlay is applied\n    });\n  });\n\n  describe('Frame Processing Performance', () => {\n    it('should apply simple frame efficiently', async () => {\n      const canvas = createMockCanvas(1920, 1080);\n      \n      performanceMonitor.start();\n      const framedCanvas = await imageProcessingService.applyFrame(\n        canvas,\n        { ...mockFrameSettings, style: 'simple' }\n      );\n      const duration = performanceMonitor.end('simple-frame');\n      \n      expect(framedCanvas).toBeDefined();\n      expect(duration).toBeLessThan(1000); // Should process in less than 1 second\n    });\n\n    it('should apply complex frame styles efficiently', async () => {\n      const canvas = createMockCanvas(1920, 1080);\n      const frameStyles = ['shadow', 'film', 'polaroid', 'vintage'] as const;\n      \n      for (const style of frameStyles) {\n        performanceMonitor.start();\n        const framedCanvas = await imageProcessingService.applyFrame(\n          canvas,\n          { ...mockFrameSettings, style }\n        );\n        const duration = performanceMonitor.end(`${style}-frame`);\n        \n        expect(framedCanvas).toBeDefined();\n        expect(duration).toBeLessThan(2000); // Should process in less than 2 seconds\n      }\n    });\n\n    it('should skip frame when disabled', async () => {\n      const canvas = createMockCanvas(1920, 1080);\n      \n      performanceMonitor.start();\n      const framedCanvas = await imageProcessingService.applyFrame(\n        canvas,\n        { ...mockFrameSettings, enabled: false }\n      );\n      const duration = performanceMonitor.end('no-frame');\n      \n      expect(framedCanvas).toBe(canvas); // Should return the same canvas\n      expect(duration).toBeLessThan(10); // Should be almost instant\n    });\n  });\n\n  describe('Export Performance', () => {\n    it('should export JPEG efficiently', async () => {\n      const canvas = createMockCanvas(1920, 1080);\n      \n      performanceMonitor.start();\n      const blob = await imageProcessingService.exportImage(canvas, 'jpeg', 0.9);\n      const duration = performanceMonitor.end('jpeg-export');\n      \n      expect(blob).toBeDefined();\n      expect(blob.type).toBe('image/jpeg');\n      expect(duration).toBeLessThan(1000); // Should export in less than 1 second\n    });\n\n    it('should export PNG efficiently', async () => {\n      const canvas = createMockCanvas(1920, 1080);\n      \n      performanceMonitor.start();\n      const blob = await imageProcessingService.exportImage(canvas, 'png');\n      const duration = performanceMonitor.end('png-export');\n      \n      expect(blob).toBeDefined();\n      expect(blob.type).toBe('image/png');\n      expect(duration).toBeLessThan(2000); // PNG might take a bit longer\n    });\n\n    it('should handle export errors gracefully', async () => {\n      const canvas = createMockCanvas(1920, 1080);\n      \n      // Mock toBlob to fail\n      canvas.toBlob = vi.fn((callback) => {\n        callback?.(null);\n      });\n      \n      await expect(imageProcessingService.exportImage(canvas, 'jpeg'))\n        .rejects\n        .toThrow('图像导出失败');\n    });\n  });\n\n  describe('Memory Management', () => {\n    it('should manage memory efficiently during processing', async () => {\n      const initialMemory = getMemoryUsage();\n      \n      // Process multiple images\n      const files = Array.from({ length: 5 }, (_, i) => \n        createMockFile(`test-${i}.jpg`, 'image/jpeg', 1000000)\n      );\n      \n      for (const file of files) {\n        const image = await imageProcessingService.loadImage(file);\n        const canvas = await imageProcessingService.applyOverlay(\n          image,\n          mockPhotoMetadata,\n          mockOverlaySettings\n        );\n        const framedCanvas = await imageProcessingService.applyFrame(canvas, mockFrameSettings);\n        await imageProcessingService.exportImage(framedCanvas, 'jpeg');\n      }\n      \n      const finalMemory = getMemoryUsage();\n      \n      // Memory usage should not increase dramatically\n      if (initialMemory.total > 0) {\n        const memoryIncrease = finalMemory.used - initialMemory.used;\n        const increasePercentage = (memoryIncrease / initialMemory.total) * 100;\n        expect(increasePercentage).toBeLessThan(50); // Should not increase by more than 50%\n      }\n    });\n\n    it('should clear cache when memory pressure is detected', async () => {\n      // This test would require actual memory pressure simulation\n      // For now, we'll test the cache clearing mechanism directly\n      const file1 = createMockFile('test1.jpg', 'image/jpeg', 1000000);\n      const file2 = createMockFile('test2.jpg', 'image/jpeg', 1000000);\n      \n      // Load images to populate cache\n      await imageProcessingService.loadImage(file1);\n      await imageProcessingService.loadImage(file2);\n      \n      // Simulate memory pressure by calling the private method\n      // (In a real scenario, this would be triggered automatically)\n      const service = imageProcessingService as any;\n      if (service.clearImageCache) {\n        service.clearImageCache();\n      }\n      \n      // Verify that subsequent loads work correctly\n      const image = await imageProcessingService.loadImage(file1);\n      expect(image).toBeDefined();\n    });\n  });\n\n  describe('Error Handling and Recovery', () => {\n    it('should handle image loading timeout', async () => {\n      // Mock Image to never load\n      const OriginalImage = global.Image;\n      global.Image = class MockTimeoutImage {\n        onload: (() => void) | null = null;\n        onerror: (() => void) | null = null;\n        src = '';\n        naturalWidth = 1920;\n        naturalHeight = 1080;\n        crossOrigin = '';\n        \n        constructor() {\n          // Never call onload to simulate timeout\n        }\n      } as any;\n      \n      const file = createMockFile('timeout-image.jpg', 'image/jpeg', 1000000);\n      \n      await expect(imageProcessingService.loadImage(file))\n        .rejects\n        .toThrow('图像加载超时');\n      \n      global.Image = OriginalImage;\n    });\n\n    it('should handle canvas context creation failure', async () => {\n      // This would require mocking the canvas creation to fail\n      // For now, we'll test that the service handles null context gracefully\n      expect(() => {\n        // The service should throw an error during construction if context is null\n        const mockCanvas = {\n          getContext: () => null,\n        };\n        document.createElement = vi.fn(() => mockCanvas as any);\n        \n        // This should throw during service initialization\n        // new ImageProcessingServiceImpl();\n      }).not.toThrow(); // The service is already initialized\n    });\n\n    it('should handle processing errors gracefully', async () => {\n      const file = createMockFile('error-image.jpg', 'image/jpeg', 1000000);\n      \n      // Mock Image to trigger error\n      const OriginalImage = global.Image;\n      global.Image = class MockErrorImage {\n        onload: (() => void) | null = null;\n        onerror: (() => void) | null = null;\n        src = '';\n        naturalWidth = 1920;\n        naturalHeight = 1080;\n        crossOrigin = '';\n        \n        constructor() {\n          setTimeout(() => {\n            if (this.onerror) {\n              this.onerror();\n            }\n          }, 10);\n        }\n      } as any;\n      \n      await expect(imageProcessingService.loadImage(file))\n        .rejects\n        .toThrow('无法加载图像');\n      \n      global.Image = OriginalImage;\n    });\n  });\n\n  describe('Performance Benchmarks', () => {\n    it('should meet performance benchmarks for typical workflow', async () => {\n      const file = createMockFile('benchmark-image.jpg', 'image/jpeg', 2000000); // 2MB\n      \n      // Complete workflow benchmark\n      performanceMonitor.start();\n      \n      const image = await imageProcessingService.loadImage(file);\n      const overlaidCanvas = await imageProcessingService.applyOverlay(\n        image,\n        mockPhotoMetadata,\n        mockOverlaySettings\n      );\n      const framedCanvas = await imageProcessingService.applyFrame(\n        overlaidCanvas,\n        mockFrameSettings\n      );\n      const blob = await imageProcessingService.exportImage(framedCanvas, 'jpeg', 0.9);\n      \n      const totalDuration = performanceMonitor.end('complete-workflow');\n      \n      expect(blob).toBeDefined();\n      expect(totalDuration).toBeLessThan(5000); // Complete workflow should take less than 5 seconds\n      \n      console.log(`Complete workflow took ${totalDuration.toFixed(2)}ms`);\n    });\n\n    it('should provide performance statistics', () => {\n      const stats = performanceMonitor.getStats('complete-workflow');\n      \n      expect(stats.count).toBeGreaterThan(0);\n      expect(stats.avg).toBeGreaterThan(0);\n      expect(stats.min).toBeLessThanOrEqual(stats.avg);\n      expect(stats.max).toBeGreaterThanOrEqual(stats.avg);\n      \n      console.log('Performance Statistics:', stats);\n    });\n  });\n});\n"